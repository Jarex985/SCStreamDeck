<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,minimal-ui,viewport-fit=cover" name="viewport">
    <meta content="yes" name="apple-mobile-web-app-capable">
    <meta content="black" name="apple-mobile-web-app-status-bar-style">
    <title>Star Citizen - Settings</title>

    <!-- EasyPI Framework (for base functionality) -->
    <link href="../easy-pi/src/sdpi.css" rel="stylesheet">
    <script src="../js/sc-common.js"></script>

    <!-- Custom SC Theme -->
    <link href="../css/sc-theme.css" rel="stylesheet">

    <!-- SVG Filter for beveled border effect -->
    <svg width="0" height="0" aria-hidden="true">
        <filter id="f" color-interpolation-filters="sRGB">
            <feGaussianBlur stdDeviation="3" result="blur"/>
            <feComponentTransfer>
                <feFuncA type="table" tableValues="-2 3 -2"/>
            </feComponentTransfer>
            <feColorMatrix values="0 0 0 0 0.059
                                  0 0 0 0 0.118
                                  0 0 0 0 0.22
                                  0 0 0 0.6 0" result="line"/>
            <feComponentTransfer in="blur">
                <feFuncA type="table" tableValues="-2 3"/>
            </feComponentTransfer>
            <feComposite in="SourceGraphic" operator="in"/>
            <feBlend in="line"/>
            <feDropShadow dx="1" dy="1" stdDeviation="2" flood-color="rgba(0,217,255,0.5)"/>
        </filter>
    </svg>
</head>
<body>

<div class="sdpi-wrapper">
    <div class="sdpi-wrapper-glow"></div>

    <!-- Plugin Status Section -->
    <div class="sc-full-width">
        <div class="sc-section-header">Plugin Status</div>
        <div class="sc-status" id="pluginStatus">
            Initializing...
        </div>
    </div>

    <!-- Installation Status Section -->
    <div class="sc-full-width">
        <div class="sc-section-header">Installation</div>
        <div class="sc-status" id="installationStatus">
            Scanning...
        </div>
        <div class="sc-helper-text" id="installationPath">
            Path: Not detected
        </div>
    </div>

    <!-- Custom Path Section -->
    <div class="sc-full-width">
        <div class="sc-section-header">Custom Installation Path</div>
        <input
            type="text"
            id="customPath"
            class="sc-input"
            placeholder="e.g., D:\Games\StarCitizen\LIVE"
            autocomplete="off"
        >
        <div class="sc-helper-text">
            Optional: Override auto-detection with custom path
        </div>
    </div>

    <!-- Actions Section -->
    <div class="sc-full-width">
        <div class="sc-section-header">Actions</div>
        <button
            type="button"
            id="saveButton"
            class="sc-button"
        >
            Save Settings
        </button>
        <button
            type="button"
            id="detectButton"
            class="sc-button sc-mt-sm"
        >
            Detect Installation
        </button>
        <button
            type="button"
            id="refreshButton"
            class="sc-button sc-mt-sm"
        >
            Refresh Status
        </button>
    </div>

    <!-- Last Updated Section -->
    <div class="sc-full-width">
        <div class="sc-helper-text" id="lastUpdated">
            Last updated: Never
        </div>
    </div>

</div>

<script>
    // #region Global State

    /**
     * Current plugin state
     * @type {Object}
     */
    let pluginState = {
        pluginInitialized: false,
        installationFound: false,
        installationPath: '',
        customPath: '',
        lastUpdate: null
    };

    // #endregion

    // #region Status Management

    /**
     * Update the plugin status display
     * @param {string} message - Status message
     * @param {string} [state] - State: 'success', 'warning', 'error', 'info'
     */
    function updatePluginStatus(message, state = 'info') {
        const statusEl = getElement('pluginStatus');
        if (!statusEl) return;

        setText('pluginStatus', message);

        // Remove all state classes
        statusEl.classList.remove('success', 'warning', 'error');

        // Add requested state class if valid
        if (['success', 'warning', 'error'].includes(state)) {
            statusEl.classList.add(state);
        }
    }

    /**
     * Update the installation status display
     * @param {boolean} found - Whether installation was found
     * @param {string} [path] - Installation path
     */
    function updateInstallationStatus(found, path) {
        const statusEl = getElement('installationStatus');
        const pathEl = getElement('installationPath');

        if (!statusEl || !pathEl) return;

        // Update state
        statusEl.classList.remove('success', 'warning', 'error');

        if (found) {
            setText('installationStatus', 'Installation Found');
            statusEl.classList.add('success');
            setText('installationPath', `Path: ${path || 'Unknown'}`);
        } else {
            setText('installationStatus', 'Installation Not Found');
            statusEl.classList.add('warning');
            setText('installationPath', 'Path: Not detected - try custom path');
        }

        // Update internal state
        pluginState.installationFound = found;
        pluginState.installationPath = path || '';
    }

    /**
     * Update the last updated timestamp
     */
    function updateLastUpdated() {
        const now = new Date();
        const timeString = now.toLocaleTimeString();
        setText('lastUpdated', `Last updated: ${timeString}`);
        pluginState.lastUpdate = now;
    }

    // #endregion

    // #region EasyPI Integration

    /**
     * Override EasyPI's loadConfiguration to restore saved settings
     */
    const originalLoadConfiguration = loadConfiguration;
    loadConfiguration = function(payload) {
        // Call original to handle other properties
        originalLoadConfiguration(payload);

        // Restore custom path if saved
        if (payload && payload.customPath) {
            setValue('customPath', payload.customPath);
            pluginState.customPath = payload.customPath;
        }

        // Restore other settings
        if (payload && payload.installationPath) {
            pluginState.installationPath = payload.installationPath;
        }
    };

    // #endregion

    // #region Button Handlers

    /**
     * Handle Save button click
     * Sends current settings to plugin
     */
    function handleSave() {
        const customPath = getValue('customPath').trim();

        // Prepare settings payload
        const settings = {
            customPath: customPath,
            timestamp: Date.now()
        };

        try {
            // Send settings to plugin
            sendToPlugin('saveSettings', 'property_inspector', settings);

            // Show feedback
            updatePluginStatus('Settings saved', 'success');
            updateLastUpdated();
        } catch (e) {
            updatePluginStatus('Failed to save settings', 'error');
        }
    }

    /**
     * Handle Detect Installation button click
     * Requests plugin to detect Star Citizen installation
     */
    function handleDetect() {
        try {
            updatePluginStatus('Detecting installation...', 'info');
            sendToPlugin('detectInstallation', 'property_inspector');
        } catch (e) {
            updatePluginStatus('Detection failed', 'error');
        }
    }

    /**
     * Handle Refresh Status button click
     * Requests plugin to send current status
     */
    function handleRefresh() {
        try {
            updatePluginStatus('Refreshing status...', 'info');
            sendToPlugin('refreshStatus', 'property_inspector');
        } catch (e) {
            updatePluginStatus('Refresh failed', 'error');
        }
    }

    // #endregion

    // #region WebSocket Communication

    /**
     * Handle incoming WebSocket messages from plugin
     * Processes status updates, installation detection results, etc.
     */
    onWebSocketReady(function() {
        const originalOnMessage = websocket.onmessage;

        websocket.onmessage = function(evt) {
            const jsonObj = JSON.parse(evt.data);

            // Handle sendToPropertyInspector events
            if (jsonObj.event === 'sendToPropertyInspector' && jsonObj.payload) {
                const payload = jsonObj.payload;

                // Plugin status update
                if (payload.pluginStatus) {
                    const status = payload.pluginStatus;
                    let state = 'info';
                    let message = 'Ready';

                    switch (status) {
                        case 'initialized':
                            message = 'Plugin Ready';
                            state = 'success';
                            pluginState.pluginInitialized = true;
                            break;
                        case 'initializing':
                            message = 'Initializing...';
                            state = 'info';
                            break;
                        case 'error':
                            message = 'Plugin Error';
                            state = 'error';
                            break;
                        default:
                            message = status;
                    }

                    updatePluginStatus(message, state);
                }

                // Installation detection result
                if (payload.installationDetected !== undefined) {
                    updateInstallationStatus(
                        payload.installationDetected,
                        payload.installationPath
                    );
                }

                // Settings saved confirmation
                if (payload.settingsSaved) {
                    updatePluginStatus('Settings saved successfully', 'success');
                    updateLastUpdated();
                }

                // General status message
                if (payload.status && !payload.pluginStatus) {
                    updatePluginStatus(payload.status);
                }
            }

            // Call original handler
            if (originalOnMessage) {
                originalOnMessage.call(this, evt);
            }
        };
    });

    // #endregion

    // #region Event Listeners

    /**
     * Initialize event listeners when DOM is ready
     */
    onDocumentReady(function() {
        // Save button
        addEventListener('saveButton', 'click', handleSave);

        // Detect button
        addEventListener('detectButton', 'click', handleDetect);

        // Refresh button
        addEventListener('refreshButton', 'click', handleRefresh);

        // Notify plugin that Property Inspector is ready
        try {
            notifyPluginConnected('property_inspector');

            // Request initial status
            setTimeout(function() {
                handleRefresh();
            }, INITIAL_STATUS_DELAY);
        } catch (e) {
            updatePluginStatus('Initialization failed', 'error');
        }
    });

    // #endregion
</script>
</body>
</html>
